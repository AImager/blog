---
title: 工作总结
layout: post
tag: [随笔]
---


## 服务架构

在还未涉猎足够多的需求场景之前，我只能谈面向服务的架构，事实是，大数据趋势下需要的分布式能力也很容易被面向服务的架构所组织和使用。

SOA和微服务是面向服务架构里面两个很火的概念，但两者的区别大家一直都在争论，关于争论的具体细节就不贴了，大家google一下就了解了，这里只说下个人的观点，那就是『两者在工程上没有区分的必要』，为什么这么说呢？我们不妨先来看看大家争论区别的关键点是什么，主要是两块，一是中心化和ESB总线，二是服务的边界。一个个说，先说第一点，SOA采用星型结构设计，通信都需要走中心节点，即总线，而微服务则走去中心化的路线，但在实际工程中，某种小范围的中心化更容易管理和统一，比如数据集成和分发、异步中间件等，而整体上，为了保证高可用，服务间的调用经常会不走某个特定节点，所以是否采用中心化的方案、何时采用实际上还是由业务决定，而不是我们当前采用SOA或者微服务就一定要中心或者去中心了，那么从这个角度讲，SOA和微服务都没法提供完善的最佳实践，区分不区分意义就不大了。再说服务边界，这本身是极难确定的，即使OASIS给出了SOA的标准定义，在真正进行服务分割的时候，标准上的划分办法还是难以执行，这都源于业务场景的复杂性和概念现实的难对应性。既然概念本身没法帮我们解决问题、提供更好的实践，不如取概念中的精华，关注业务，该中心化的中心化，该拆分服务的拆分服务，以解决问题、发现问题、预测问题做指导，结果总是会更好的。

抛开SOA和微服务的抉择，聚焦到具体业务，接下来需要做的就是层次的划分和服务的划分。对于一个O2O的小体量企业而言，层次的划分几乎都可以照搬『数据层、公共子模块、业务层、前端』这样的结构，所以不做赘述。这里只单独提下公共子模块，类似推送、短信这些极其通用的模块因为每个公司几乎都有用到，所以抽象出来的技能很容易被循环使用，而随着互联网创业潮发展起来的一批BaaS企业也更加降低了这层的门槛（同时也屏蔽了硬件层），使得这一层在整个开发周期上占比愈发的少，当然对这一层的业务有高要求的另算，比如无延时推送，精准定位等。

一个微服务只做一件事，事实上这种划分原则几乎所有人都同意，但什么叫一件事？营销系统只做营销，积分营销系统也只做积分营销，但两者显然有包含关系，所以服务划分最终还是转换到对服务能力边界以及服务能力粒度的确定上。理论上分析，一个服务过粗过大就会出现臃肿、维护麻烦、迭代慢的问题，而过细则会带来依赖处理麻烦、集成困难的问题。举个实际的例子，最初推送是由业务层直接调用第三方推送完成的，但由于需要推送的设备类型和业务模块很多，所以考虑做一个推送服务模块，为了把推送内容的生成控制在业务层，推送服务模块完全做成了业务无关的形式，结果随着业务层对推送的要求逐渐增加，很多业务层做不了或做不好的事开始往推送上加，导致推送服务开始加入和业务相关的推送内容处理逻辑，这就使每次这部分更改的时候都需要同步，白白double了修改时间和沟通时间，而这些问题就是由于对推送模块所应当承担的功能划分的不当导致的。说了这么多，有没有实用的划分方案，我的想法是，『不断拆分成更加简单清晰的模块，拆分到只用一个名词来描述模块为止』，不过这只是我分析我们架构迭代后得到的简单结论，也许换个场景就会出问题，所以还需多加斟酌和学习。


## 业务服务设计

个人观点是，在面向服务的架构下，单个业务服务设计主要取决于接口设计和数据库设计，


## 数据仓库

互联网公司，大家都靠着一堆指标做运营，所以数据重要，数仓也重要，而对于面向B端的公司而言，看数据的除了运营还有商户，那么数据的意义就又上升了一个层次。既然是做数仓，必然会考虑ETL流程，至于是通过ETL工具还是代码本身是经过一番讨论和调研的，但列出的优缺点和网上说的并没有什么本质区别，支持工具的还是支持工具，支持代码的还是支持代码，后来大家达成共识，觉得与其争论一些没结果的，不如先做做看，所以代码派[me]暂时放弃了个人追求，统一使用ETL工具处理。工具我们选用了开源ETL届的杠把子——Kettle，在用Kettle搭建了一个还算完整的数仓后，结合之前的代码经验回过头来看ETL工具与代码之争，



## 前端

这块处理的不多，但下意识的认为工程化很重要，还需要学习以及深入的思考。

## 运维

信号量的问题、内存泄露的问题、数据维护、监控

## 算法与数学

离开了学校，算法用到的比想象中的还少，刷题的习惯也因为工作停了好长时间，不过前段时间开始捡起来了，不知道是对深度学习产生了兴趣，还是希望换点东西学，但不管怎么样，是好事，就是时间总是个大问题。

## 机器学习

『对于某类任务T和性能度量P，如果一个计算机程序在T上以P衡量的性能随着经验E而自我完善，那么我们称这个计算机程序在从经验E学习』，这是关于机器学习的形式化定义，所以从这个定义上走，机器学习并不困难，而这也是我可以在很短时间内一个人搭建出一个推荐系统的原因。不过，做出来不难，要做好却异常艰难，因为时间和业务的不允许，所以这一块只能算涉猎。但还是希望在学校里打的一些数学建模的底子未丢掉前，能抽出更多的时间学习下。

## 技术栈

接触了一些


## 需求迭代

如果再给我一次机会，我希望重写代码，相信每个程序员在看老代码的时候都会有这样的愿望。但实际情况是，即使给各位重构的时间，在多次产品迭代后回顾，大家还是会有这样的想法，更何况重构是少有的，时间是不够的，迭代是飞快的，所以各种老系统的设计问题被遗留下来，新需求的跟进又会因为时间的紧迫而采取最简单的兼容处理，比如复制粘贴（这里也有程序员的懒惰成分和风险考虑），这样恶性循环下来，最终到完全没法加新需求或旧有系统无法工作的情况下，重构才开始介入。

有bug立马修，不要想着重构



## 开发管理

目标：高效率+少bug

代码仓库、模块分解、运维、上线、测试、工具管理


## 经验泛化

技术方案的选择从来是个权衡的过程，因为无论哪个技术方案，都会同时包含优点和缺陷两方面，还是以ORM为例子，这东西大家争吵了十余年，说它抽象数据的还是认为它好，说它繁琐性能低的还是觉得它差，
