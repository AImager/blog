---
title: C陷阱与特性
layout: post
tags: [C]
---

这篇文章会尽量列举C语言的特性和易错点，有些内容可能直接来自于其它书籍，如《C陷阱和缺陷》、《C专家编程》等。

## C标准史

~~~Text
1989：J11于1983年开始起草的C标准草案完成且通过ANSI，从而成为美国标准，即C89（后面如果不加声明，默认以此为标准）
1990：C89通过ISO正式成为全球标准，即C90——对C89在排版上有一点区别，技术无区别
1994：对C90进行勘误
1995：对C90进行很少的扩充，即C95
1996：对C95进行勘误
1999：对C95进一步扩充（改动较大），即C99，但目前大部分编译器并不能完全支持C99
~~~

## 关键字（C89共32个关键字，C99共37个关键字）

~~~Text
存储属性关键字（4个）
  auto：自动局部变量——默认隐藏，在函数体中碰见被定义后分配空间，函数体完成后撤销
  static：静态局部变量——编译时分配空间，始终占用内存单元
  register：寄存器变量——变量直接放在CPU的寄存器中
  extern：外部变量，提示在其它函数体或文件中寻找定义的变量——公用此变量

数据类型关键字（12个）
  int
  short
  long
  float
  double
  char
  struct
  union（联合类型）
  enum（枚举类型）
  void
  unsinged
  singed

控制语句关键字（12个）
  if
  else
  switch
  case
  default
  do
  while
  for
  return
  goto
  continue
  break

C89其它关键字（4个）
  typedef：变量取别名——相当于一个函数
  const：声明只读变量
  volatile：声明变量可隐含改变
  sizeof：计算数据长度——相当于一个函数

C99新增关键字（5个）
  restrict：用来限定指针，表明指针是访问一个数据对象的唯一且初始化对象
  inline：内联函数关键字，提高编译器效率
  _Complex：复数存储类型关键字
  _Imaginary：虚数存储类型关键字
  _Bool：bool存储类型关键字
~~~

## 控制语句（9种）

~~~Text
条件控制
  if语句
  switch语句

循环控制
  do-while语句
  while语句
  for语句

跳转语句
  return语句
  goto语句
  continue语句
  break语句
~~~

## 运算符类型（结合方向）（运算符个数）

~~~Text
【共44个运算符，按优先级排序，从上往下优先级降低，同级相等】

初等运算符（左到右）（4）：( )   [ ]   .   ->（连接指针变量与结构体成员）
单目运算符（右到左）（9）：!   ~（位反）   ++   --   -   *   &   sizeof  ( )（用于强制类型转换）
算数运算符（左到右）（3）：*   /   %
算数运算符（左到右）（2）：+   -
位运算符（左到右）（2）：<<（位左移）   >>（位右移）
关系运算符（左到右）（4）：>   >=   <   <=
关系运算符（左到右）（2）：==   !=
位运算符（左到右）（1）：&（位与）
位运算符（左到右）（1）：^（位异或）
位运算符（左到右）（1）：|（位或）
逻辑运算符（左到右）（1）：&&
逻辑运算符（左到右）（1）：||
条件运算符（右到左）（1）：?:（条件求值）
赋值运算符（右到左）（11）：=   +=   -=   *=   %=   >>=   <<=   &=   ^=   |=   /=
逗号运算符（左到右）（1）：,（顺序求值）
~~~

## 功能

### 动态参数

~~~C
#include <stdarg.h>

type operName(type firstarg, ...){
    va_list ptr;
    va_start(ptr, firstarg);
    va_arg(ptr,nexttype);    //切换到下一个参数，返回下一个参数的值
    va_end(ptr);
}
~~~


## 数据类型

### IEEE754

定点数分定点整数和定点小数，原理是均只进行整数运算，定点整数运算就等同于int计算，而定点小数运算一般在单片机（DSP等）才有（因为单片机不需要太大数据计算量，且性能有限，浮点运算就没大必要了）。比如对16位数，1位符号位，3位整数位，12位小数位（定点就没必要记录小数点），2.5的存储位表示为0010 1000 0000 0000
数组与指针的区别

~~~C
double test6_1=0.1;
printf("%20.19lf\n",test6_1);
~~~


### unsigned

关于signed/unsigned，有无符号是针对编译以上级别而言的，本质（存储）是一样的，而在运算的时候，则是先将补码转换为原码进行计算，然后再转换为补码。这里就有个问题——变量开头为1时，把变量当作负数（signed）和正数（unsigned）计算的结果会不一样，什么情况下需要考虑这种问题呢——强制转换的时候（signed与unsigned混合运算时）。

unsigned int a=1; int b=-2; 则a+b>0，我们想的是1-2=-1\<0，但实际上a为unsigned，b为signed，为保证不损失信息（强制转换的原则），系统把b当作unsigned计算得到一个unsigned值，虽然得到的结果存储信息始终为0xffffffff(可表示-1也可表示超大正整数)，但这里是当作unsigned处理的，所以就得到了非预想的结果。






## 词法


### 词法规则

所有元素被划分为6类：标识符、关键字、常量、字符串字面值、运算符、其它分隔符

空格、横向/纵向制表符、换行符、换页符、注解（合称为空白符）被略过



### 词法分析的『贪心法』

原则：尽可能多的读取多的字符作为一个组合，如果正在读取的字符可以和当前字符组组成一个组合，那就将这个字符加入当前字符组，然后继续读入，直到不能组成组合，就清空当前字符组，重新开始，看下面的例子：

~~~
a---b    // 等同于(a--)-b，自减最后算

y/*p    // /*作为注释的开始

*p++ = val;  //将val进行压栈

val = *--p;  //将val弹出栈
~~~

### 标识符

标识符的命名原则——字母、数字、下划线，首位不能用数字


### /\*/\*/0\*/\*\*/1

ANSI标准C是不支持注释嵌套的，但有的编译器在实现的时候还是支持的

支持嵌套的时候：贪心法[1~2]作为单运算符，[3~4]继续作单运算符——匹配[7~8]，则/0作为注释内容，[10~11]匹配[1~2]，则*作为注释内容，结果为1

不支持嵌套的时候：贪心法[1~2]作为单运算符，此时后面出现的/\*均不算数（直到第一个\*/结束），则[3]作为单运算符，[4~5]由贪心法作为单运算符匹配[1~2]，此时/作为注释内容，而后0*是未注释部分，[8~9]作为新注释匹配[10~11]，1未注释，则去掉注释内容后结果为0\*1=0



## 语法

### ++

++前缀先算，后缀如果在混合运算中，先忽略掉，即直接算混合运算，混合运算算完后再进行单独的后缀运算，++必须紧跟值而不能跟表达式

### 括号

* 圆括号：圆括号代表最高优先级的运算符，一个圆括号内的表达式无论多么复杂，其最终只返回一个数据
* 花括号：花括号代表一个代码区块，是一个作用域

### switch

~~~
switch (color){
  case 1: printf("red");
  case 2: printf("black");
  case 3: printf("blue");
}
~~~

如果color值为2，得到的结果为blackblue

### 结合性

C标准中没有给出结合性的标准说明，不过一个比较正确的理解是『在一个表达式中，如果多个符号的优先级相同，那就按结合性选择运算顺序』，如a=b=c，=是从右下向左的结合性，所以先算后面的=再算前面的


### 求值顺序

和求值顺序有关的只有四个运算符

~~~
&&  先算左边，左边为True时算右边
||  先算左边，左边为False时算右边
,   先算左边，算完后扔掉再算右边
?:  先算最前面，True就算中间，False就算后面
~~~






## 指针

### 一些名词

* 野指针：指针指向的动态内存被释放后，没有将指针赋为NULL
* 柔性数组：在结构体的最后面（前面必须有变量）可定义一个可变长度的数组，但是这个数组不计入结构体的长度，至于其具体长度在使用的时候用动态内存（malloc等）生成，生成的长度减去结构体前面变量的长度就是数组的长度
* 函数指针：每次函数名用到的地方都是将函数名转换为指针再使用，而&函数名实际上只是对这个操作显示的表达出来——方便阅读，没任何本质区别


### 结构体和函数

结构体名只是标识符，并不代表指针

结构体或联合数据生成时要进行内存对齐（硬件性能与数据存储的原因），至于是否对齐和怎么对齐和硬件有关（x86内存每4个字节对齐），C语言允许通过预处理命令#pragma pack(n)来指定n值（即对齐字节数）

~~~C
struct test2_1{
	char test2_2;
	double test2_3;
	int test2_4[3];
}test2_5={'c',8.0,2,3,4};

printf("%p %p %p\n ",&test2_5.test2_2,&test2_5.test2_3,test2_5.test2_4);
int test2_6[3]={1,2,3};
printf("%p %p\n",&test2_6,&test2_6[0]);
~~~

### const与指针传递类型

~~~
指向非常量数据的非常量指针：char \*str
指向非常量数据的常量指针：char \*const str
指向常量数据的非常量指针：const char \*str
指向常量数据的常量指针：const char \*const str
~~~







## sizeof

sizeof不是一个函数，字节数的计算在程序编译时进行，通过下面这个例子可以证明这一点

~~~
// test.c

#include <stdio.h>

int main(){
  int a = sizeof 1;
  return 0;
}
~~~

~~~
;编译但不链接test.c文件
> gcc -c test.c -o test.o

;反汇编查看test.o
> objdump -d test.o

00000000 <main>:
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 10             	sub    $0x10,%esp
   6:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%ebp)
   d:	b8 00 00 00 00       	mov    $0x0,%eax
  12:	c9                   	leave
  13:	c3                   	ret

~~~

* 为避免麻烦，使用sizeof最好加上括号。
* 根据sizeof我们可以引出指针和数组的不同，当a分别为10字节字符数组和字符串指针时，sizeof(a)分别返回10和4，也就是数组名并不是纯粹意义上的指针，数组是C语言必不可少的内建类型。
* 对数组只有两种特殊操作——得到数组的大小和确定数组各位置的指针，而其它所有操作都可以转换为对应的指针操作。
* sizeof空结构体不为0，结果为多少由编译器决定，但实际在内存中不占位置，只是为了表明这里有变量占用。

~~~C
struct test1_1{
	double test1_2;
	char test1_3;
	struct test1_1 *test1_4;
}*test1_5;

printf("%d\n",sizeof(test1_5));
double test1_6=3.0,*test1_7;
test1_7=&test1_6;
double test1_8[3]={1,2,3};
printf("%d\n",sizeof(test1_7));
printf("%d\n",sizeof(test1_8));
~~~


### sizeof与strlen

~~~C
char test12_1[6]="12345";
printf("%d %d\n",sizeof(test12_1),strlen(test12_1));
~~~




## 函数

### int argc, char \*argv[]

用于程序开始执行时的参数传入，argc表示参数个数，argv表示字符串数组，每个字符串算一个参数，调用程序时的程序名始终作为第一个参数


### 参数传递

无论是实参还是形参传递其值都是采用中间变量存储，实参没什么好证明的，直接证明形参（还是通过objdump反编译查看）

~~~C
;代码
#include <stdio.h>

void test(int a){}

int main(){
  int a = 2;
  test(a);
  return 0;
}


;反编译代码
080483b4 <test>:
 80483b4:	55                   	push   %ebp
 80483b5:	89 e5                	mov    %esp,%ebp
 80483b7:	5d                   	pop    %ebp
 80483b8:	c3                   	ret

080483b9 <main>:
 80483b9:	55                   	push   %ebp
 80483ba:	89 e5                	mov    %esp,%ebp
 80483bc:	83 ec 14             	sub    $0x14,%esp
 80483bf:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
 80483c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
 80483c9:	89 04 24             	mov    %eax,(%esp)
 80483cc:	e8 e3 ff ff ff       	call   80483b4 <test>
 80483d1:	b8 00 00 00 00       	mov    $0x0,%eax
 80483d6:	c9                   	leave
 80483d7:	c3                   	ret
~~~

查看反编译代码，80483bf用于赋值a（在C语言程序中a是放在栈中的，关于C内存详情，后面有讲），80483c6用于把a的值传到eax寄存器，80483c9用于将eax中的值传到esp的内存区域（这就是在生成变量副本，为调用函数做准备），80483cc则显然是在调用函数







## 内存分配

* 局部变量存储在栈中
* 动态申请的存储在堆中
* 字符串常量存储在静态存储区
* 初始化的全局变量、静态变量存储在静态存储区
* 未初始化的全局变量、静态变量存储在BSS区


C语言中文件系统分缓冲文件系统和非缓冲文件系统（和使用的类库有关），缓冲文件系统会在进行文件读写操作时，自动为每一个正在使用的文件分配一个缓冲区（内存的一部分），当读写文件时，先经过缓冲区，等缓冲区被数据装满，在过到磁盘文件或者内存数据中去，缓冲区大小有C语言系统决定（一般512字节），如结构体类型FILE（已经定义好了的），里面包含与文件有关信息——缓冲区大小、缓冲区位置、文件的读写指针等，缓冲区的意义在于加大读写速度，而且可以通过操作缓冲区（C语言中的库函数）来实现一些特殊的功能




## 标准中产生的问题

* C99之前的C变量的声明必须在开头
* C99协定int main为最合适的写法
* 关键字const、signed、volatile是ANSI标准中新增加的
* enum和void是ANSI之前新增加的
* entry曾经被保留为关键字






## side effect

## Undefined behavior

## Implementation-defined behavior

## Unspecified behavior
