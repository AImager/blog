---
title: 历史拉链表遇到的问题
layout: post
tag: [mysql, 拉链表]
---

历史拉链表是处理增量数据很好的方式，节约了存储空间，也方便历史数据的读取，但实际在做的过程中却也引出了一堆问题。

## 基础

历史拉链是一种设计方式，关系数据库中，通过开始时间和结束时间标识元组，在这段时间内，元组的其它元素都是不变的。所以如果设计一张关系历史拉链表，开始时间和结束时间理论上必须被包含在主键中，之所以说包含，是因为可能存在其它字段一起构成主键，比如一张用户历史拉链表中，不同的用户历史拉链是不同的，所以用户也包含在主键中。

历史拉链表一般用来搜索在某个时间点的数据信息，比如下表，通过`where uid = 1 and start_time <= '2016-10-12' and end_time > '2016-10-12'`就可以拿到用户1在2016-10-12的数据。2016-10-12用户1数据发生变化，插入一条2016-10-12~2030-01-01的数据，然后`update table set end_time = '2016-10-12' where uid = 1 and start_time <= '2016-10-11' and end_time > '2016-10-11'`，仔细看where子句是通过前一天查询最后一条数据，这样更新和插入操作可以无序，而且OLAP中数据重跑也可以从出错那天开始。

| uid | start_time | end_time | field1 | field2 |
| :-----: | :----: | :----: | :----: | :----: |
| 1 | 2015-12-12 | 2016-02-16 | 1 | 2 |
| 1 | 2016-02-16 | 2016-07-14 | 3 | 6 |
| 1 | 2016-07-14 | 2030-01-01 | 4 | 7 |
| 2 | 2015-12-12 | 2030-01-01 | 12 | 12 |


## 事务

OLTP中，如果采用历史拉链表，**一定要做事务**！


## 性能

因为每次插入都伴随一次更新操作，所以插入会比较慢。删除则伴随两次更新操作，但一般不会做删除操作，即使做也不做硬删除。OLTP中看具体的场景优化，OLAP则采用挪表的方式解决更新慢的问题，如果是定时数据而且拉数据的时间分片，可以考虑是用分区表。


## 监控

历史拉链表要做定期监控，因为很容易出错，而且出错了问题很大，尤其是在数据有历史依赖关系的表中，出错了更麻烦。不过有历史依赖的历史拉链表不会也不赞成用在OLTP中，因为在OLAP中如果出错了可能还能重跑，OLAP中出错了那只能手动修了。话说前段时间看了阿里的大数据系统演讲，说流处理的中间结果可以保证100%的正确性，我在想真的假的，真的就太牛逼了。

## 历史数据

OLAP中这是个麻烦事，尤其是在老系统设计糟糕的情况下，只提一点，历史数据分段跑，**跑一段测试一段数据正确性**，不然跑完了发现错了一点会哭的。
