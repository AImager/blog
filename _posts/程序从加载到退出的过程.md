---
title: 程序从加载到退出的过程
layout: post
tag: [计算机原理,进程管理,nasm,编译,链接]
---

文章题目很大，但想了下还是找不出更好的题目来替换（文字功底有限），所以只能想办法慢慢的填这个大坑。在开始之前，先介绍下环境和工具，系统是基于Parallels（主系统为OS X）的Ubuntu32位虚拟机，版本号12.04，但我也实验过centos，基本没有区别，而用于分析的程序由nasm汇编语言编写，nasm的版本号为2.09.10，之所以采用nasm编写程序，是为了简化编译链接过程，避免最后的目标文件中太多无关段影响分析，主要的分析工具为readelf和objdump。

分析ELF文件前，有必要搞清楚什么是ELF文件，所谓ELF文件实际上就是ELF格式的文件，在linux下用过gcc的童鞋都知道，只编译不链接会产生.o文件，既编译又链接则会产生可运行的文件，而这两类都属于ELF文件，除此之外，


可重定位文件
可执行文件
共享目标文件
核心转储文件

通过file命令可查看相应的文件格式




```nasm
; ~/test/test.asm

[section .data]  ;数据段
	dataAdd db 1
[section .text]  ;代码段
	global _start
	_start:
		mov al,2
		mov [dataAdd],al
		jmp _start   ;循环
```

```
> nasm -f elf test.asm -o test.o

> ld -s test.o -o test

> ld -m elf_i386 -s -o hello hello.o
```

通过nasm编译链接后得到一个ELF可执行文件test，其中ELF重要信息如下

```
ELF header：
	…
	Entry point address（装载逻辑地址）：08048080h（这个地址由编译器决定，但编译器不独立于操作系统）
	…

Section header：
	…
	段.text：载入地址8048080h，段大小Ch，段在文件中的偏移80h
	段.data：载入地址804908Ch，段大小1h，段在文件中的偏移8Ch
	…
```



```
readelf -S
readelf -h
objdump -d
hexdump -C
```


物理页（页框）通过mem_map（一个结构体）进行管理，而同时有一个bitmap来管理空闲页框

32位地址后12位用于存储偏移地址，前10位用于存储页目录，中间10位用于存储页表，则8048080表示是32号页目录、72号页表、80h偏移






## 多级页表不能节省内存

不知道是谁开始传出来的多级页表可以节省内存。实际上，几乎所有操作系统的书籍上都未表明这一点，以汤子瀛的考研操作系统书为参考，里面对多级页表的描述为『对于要求连续的内存空间来存放页表的问题，可利用将页表进行分页』，而对于占用内存太大的问题，操作系统是通过『只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入』来解决的，所以多级页表实际上是为了解决『不容易找到连续的大存储空间』这个问题的。而在《Linux内核源代码情景分析》这本书中则明确表示以32位Linux为例，二级页表所需空间为4KB+4MB，但为了节省空间，开始只分配4KB的页目录和部分页表，其它页表会采用**单独的算法**进行动态载入。当然，前面说了『几乎所有的操作系统书籍』，所以也有那么些书表明了这个错误观点，比如在豆瓣上评分颇高的《深入Linux内核架构》。




所有进程PCB（task_struct）组成一个环形双向链表

mm中的mmap_avl维护AVL树


程序开始运行的时候分配多大内存（是直接把程序全加载到内存？）

装载是直接把分配的内存装满还是按《程序员的自我修养》中说的那样一个一个页中断的加载
