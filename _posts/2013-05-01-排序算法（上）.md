---
title: 排序算法（上）
layout: post
tag: [排序,算法]
---

上篇我们介绍三种O(n^2)排序算法——选择、插入、冒泡


## 选择排序

**一句话说明：**不断从未排序好的序列中选出最小的元素加到排序好的序列后面

步骤

```
1、v=0
2、v++, a_1~a_v-1已经排序好
3、若v==n，结束排序
4、寻找出a_v~a_n中的最小数a_m
5、交换a_v与a_m [注意：一般说的是将a_m插到a_v~a_m-1前面，但这显然浪费时间]，跳到步骤3
```

核心步骤示例

```
 4   '3'   6    5                  步骤2：v=1, v!=n + 步骤3：找到a_2最小
 3   '4'   6    5                  步骤4：交换a_1与a_2 + 步骤2：v=2, v!=n + 步骤3：找到a_2最小
 3    4    6   '5'                 步骤4：不用交换 + 步骤2：v=3, v!=n + 步骤3：找到a_4最小
 3    4    5    6                  步骤4：交换a_3与a_4 + 步骤2：v=4==n，结束
```　　

C代码

```c
void Decision_sort(int *previousInd , int n){
  int v,m,j,min,temp;
  for(v=1;v<n;v++){
    min=previousInd[v-1];
    m=v;
    for(j=v+1;j<=n;j++){
      if(previousInd[j-1]<min){
        min=previousInd[j-1];
        m=j;
      }
    }
    temp=previousInd[v-1];
    previousInd[v-1]=previousInd[m-1];
    previousInd[m-1]=temp;
  }
}
```


## 插入排序

**一句话说明：**不断的从后续序列（未排序）中选择元素加到已排序好的序列中去，并形成新的排序序列

步骤

```
1、m=1　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
2、m++，v=1，a_1~a_m-1已经排序好　　　　　　　　　　　　　　　　　　
3、若m==n+1，排序结束　　　　　　　　　　　　　　　　　　
4、比对a_v和a_m，若a_v>a_m，跳到步骤6　　　　　　　　　　　　　　　　　　　　　　
5、v++，若v==m，则跳到2，否则跳到步骤4
6、将a_v~a_m-1右移一格，a_v=a_m，跳到步骤2
```

核心步骤示例

```
 2    4    5    6   <---    4           步骤2：m=5, v=1, a_1~a_4已经排序好 + 步骤3：m!=n+1
'2'   4    5    6     <    '4'          步骤4：a_1<a_5
 2   '4'   5    6     <    '4'          步骤4：a_2<=a_5
 2    4   '5'   6     >    '4'          步骤4：a_3>a_5
 2    4    4    5    6                  步骤6：temp=a_5=4, a_5=a_4=6, a_4=a_3=5, a_3=temp=5　
```

C代码

```c
void Insert_sort(int *previousInd , int n){
  int m,v,k,temp;
  for(m=2;m<=n;m++){
    temp=previousInd[m-1];
    for(v=1;v<=m-1;v++)
      if(previousInd[m-1]<previousInd[v-1])
        break;
    for(k=m-1;k>=v;k--)
      previousInd[k]=previousInd[k-1];
    previousInd[v-1]=temp;
  }
}
```

## 冒泡排序

**一句话说明：**不断比较相邻元素，将未排序序列中最大的元素选出放到已排序序列的最左端

步骤

```
1、m=n+1
2、v=1，m--，a_m+1~a_n已排序好
3、若m==1，排序结束
3、比较a_v和a_v+1，若a_v>a_v+1，跳到步骤5
4、v++，若v==m，跳到步骤2，否则跳到步骤3
5、交换a_v与a_v+1，跳到步骤4
```
　　
核心步骤示例

```
'3'  '2'   6    4       >         步骤2：m=4, v=1 + 步骤3：a_1>a_2
 2   '3'  '6'   4       <         步骤5：交换a_1和a_2 + 步骤4：v=2 + 步骤3：a_2<a_3
 2    3   '6'  '4'      >         步骤4：v=3 + 步骤3：a_3>a_4
 2    3    4    6                 步骤5：交换a_3和a_4
```

C代码　　

```c
void Bubbling_sort(int *previousInd , int n){
  int v,m,temp;
  for(m=n;m>=1;m--){
    for(v=1;v<m;v++){
      if(previousInd[v-1]>previousInd[v]){
        temp=previousInd[v];
        previousInd[v]=previousInd[v-1];
        previousInd[v-1]=temp;
      }
    }
  }
}
```
